{"version":3,"sources":["/Users/albaortegaflores/Documentos/TFM/code/web/node_modules/ngx-quill/fesm2015/ngx-quill.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAoVE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4DAyG0D,AAoBzD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAwBD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAec","file":"ngx-quill.js","sourcesContent":["import { __decorate, __metadata, __param } from 'tslib';\nimport { InjectionToken, EventEmitter, SecurityContext, Input, Output, Component, ViewEncapsulation, forwardRef, Inject, PLATFORM_ID, ElementRef, Renderer2, NgZone, NgModule } from '@angular/core';\nimport { isPlatformServer, DOCUMENT } from '@angular/common';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';\n\nconst defaultModules = {\n    toolbar: [\n        ['bold', 'italic', 'underline', 'strike'],\n        ['blockquote', 'code-block'],\n        [{ header: 1 }, { header: 2 }],\n        [{ list: 'ordered' }, { list: 'bullet' }],\n        [{ script: 'sub' }, { script: 'super' }],\n        [{ indent: '-1' }, { indent: '+1' }],\n        [{ direction: 'rtl' }],\n        [{ size: ['small', false, 'large', 'huge'] }],\n        [{ header: [1, 2, 3, 4, 5, 6, false] }],\n        [\n            { color: [] },\n            { background: [] }\n        ],\n        [{ font: [] }],\n        [{ align: [] }],\n        ['clean'],\n        ['link', 'image', 'video'] // link and image, video\n    ]\n};\n\nconst QUILL_CONFIG_TOKEN = new InjectionToken('config');\n\nvar QuillEditorComponent_1;\n// tslint:disable-next-line:variable-name\nlet Quill = null;\nlet QuillEditorComponent = QuillEditorComponent_1 = class QuillEditorComponent {\n    constructor(elementRef, domSanitizer, doc, \n    // tslint:disable-next-line:ban-types\n    platformId, renderer, zone, config) {\n        this.elementRef = elementRef;\n        this.domSanitizer = domSanitizer;\n        this.doc = doc;\n        this.platformId = platformId;\n        this.renderer = renderer;\n        this.zone = zone;\n        this.config = config;\n        this.format = 'html';\n        this.required = false;\n        this.customToolbarPosition = 'top';\n        this.sanitize = false;\n        this.style = null;\n        this.strict = true;\n        this.customOptions = [];\n        this.preserveWhitespace = false;\n        this.onEditorCreated = new EventEmitter();\n        this.onContentChanged = new EventEmitter();\n        this.onSelectionChanged = new EventEmitter();\n        this.onFocus = new EventEmitter();\n        this.onBlur = new EventEmitter();\n        this.disabled = false; // used to store initial value before ViewInit\n        this.valueGetter = (quillEditor, editorElement) => {\n            let html = editorElement.querySelector('.ql-editor').innerHTML;\n            if (html === '<p><br></p>' || html === '<div><br><div>') {\n                html = null;\n            }\n            let modelValue = html;\n            if (this.format === 'text') {\n                modelValue = quillEditor.getText();\n            }\n            else if (this.format === 'object') {\n                modelValue = quillEditor.getContents();\n            }\n            else if (this.format === 'json') {\n                try {\n                    modelValue = JSON.stringify(quillEditor.getContents());\n                }\n                catch (e) {\n                    modelValue = quillEditor.getText();\n                }\n            }\n            return modelValue;\n        };\n        this.valueSetter = (quillEditor, value) => {\n            if (this.format === 'html') {\n                if (this.sanitize) {\n                    value = this.domSanitizer.sanitize(SecurityContext.HTML, value);\n                }\n                return quillEditor.clipboard.convert(value);\n            }\n            else if (this.format === 'json') {\n                try {\n                    return JSON.parse(value);\n                }\n                catch (e) {\n                    return [{ insert: value }];\n                }\n            }\n            return value;\n        };\n        this.selectionChangeHandler = (range, oldRange, source) => {\n            this.zone.run(() => {\n                if (range === null) {\n                    this.onBlur.emit({\n                        editor: this.quillEditor,\n                        source\n                    });\n                }\n                else if (oldRange === null) {\n                    this.onFocus.emit({\n                        editor: this.quillEditor,\n                        source\n                    });\n                }\n                this.onSelectionChanged.emit({\n                    editor: this.quillEditor,\n                    oldRange,\n                    range,\n                    source\n                });\n                if (!range && this.onModelTouched) {\n                    this.onModelTouched();\n                }\n            });\n        };\n        this.textChangeHandler = (delta, oldDelta, source) => {\n            // only emit changes emitted by user interactions\n            const text = this.quillEditor.getText();\n            const content = this.quillEditor.getContents();\n            let html = this.editorElem.querySelector('.ql-editor').innerHTML;\n            if (html === '<p><br></p>' || html === '<div><br><div>') {\n                html = null;\n            }\n            this.zone.run(() => {\n                const trackChanges = this.trackChanges || this.config.trackChanges;\n                if ((source === Quill.sources.USER || trackChanges && trackChanges === 'all') && this.onModelChange) {\n                    this.onModelChange(this.valueGetter(this.quillEditor, this.editorElem));\n                }\n                this.onContentChanged.emit({\n                    content,\n                    delta,\n                    editor: this.quillEditor,\n                    html,\n                    oldDelta,\n                    source,\n                    text\n                });\n            });\n        };\n    }\n    // tslint:disable-next-line:no-empty\n    onModelChange(_modelValue) { }\n    // tslint:disable-next-line:no-empty\n    onModelTouched() { }\n    ngAfterViewInit() {\n        if (isPlatformServer(this.platformId)) {\n            return;\n        }\n        if (!Quill) {\n            Quill = require('quill');\n        }\n        this.elementRef.nativeElement.insertAdjacentHTML(this.customToolbarPosition === 'top' ? 'beforeend' : 'afterbegin', this.preserveWhitespace ? '<pre quill-editor-element></pre>' : '<div quill-editor-element></div>');\n        this.editorElem = this.elementRef.nativeElement.querySelector('[quill-editor-element]');\n        const toolbarElem = this.elementRef.nativeElement.querySelector('[quill-editor-toolbar]');\n        const modules = this.modules || (this.config.modules || defaultModules);\n        if (modules.toolbar === undefined) {\n            modules.toolbar = defaultModules.toolbar;\n        }\n        let placeholder = this.placeholder !== undefined ? this.placeholder : this.config.placeholder;\n        if (placeholder === undefined) {\n            placeholder = 'Insert text here ...';\n        }\n        if (toolbarElem) {\n            // tslint:disable-next-line:no-string-literal\n            modules['toolbar'] = toolbarElem;\n        }\n        if (this.style) {\n            Object.keys(this.style).forEach((key) => {\n                this.renderer.setStyle(this.editorElem, key, this.style[key]);\n            });\n        }\n        this.customOptions.forEach((customOption) => {\n            const newCustomOption = Quill.import(customOption.import);\n            newCustomOption.whitelist = customOption.whitelist;\n            Quill.register(newCustomOption, true);\n        });\n        let bounds = this.bounds && this.bounds === 'self' ? this.editorElem : this.bounds;\n        if (!bounds) {\n            bounds = this.config.bounds ? this.config.bounds : this.doc.body;\n        }\n        let debug = this.debug;\n        if (!debug && debug !== false && this.config.debug) {\n            debug = this.config.debug;\n        }\n        let readOnly = this.readOnly;\n        if (!readOnly && this.readOnly !== false) {\n            readOnly = this.config.readOnly !== undefined ? this.config.readOnly : false;\n        }\n        let scrollingContainer = this.scrollingContainer;\n        if (!scrollingContainer && this.scrollingContainer !== null) {\n            scrollingContainer = this.config.scrollingContainer === null || this.config.scrollingContainer ? this.config.scrollingContainer : null;\n        }\n        let formats = this.formats;\n        if (!formats && formats === undefined) {\n            formats = this.config.formats || this.config.formats === null ? this.config.formats : undefined;\n        }\n        this.quillEditor = new Quill(this.editorElem, {\n            bounds,\n            debug,\n            formats,\n            modules,\n            placeholder,\n            readOnly,\n            scrollingContainer,\n            strict: this.strict,\n            theme: this.theme || (this.config.theme ? this.config.theme : 'snow')\n        });\n        if (this.content) {\n            if (this.format === 'object') {\n                this.quillEditor.setContents(this.content, 'silent');\n            }\n            else if (this.format === 'text') {\n                this.quillEditor.setText(this.content, 'silent');\n            }\n            else if (this.format === 'json') {\n                try {\n                    this.quillEditor.setContents(JSON.parse(this.content), 'silent');\n                }\n                catch (e) {\n                    this.quillEditor.setText(this.content, 'silent');\n                }\n            }\n            else {\n                if (this.sanitize) {\n                    this.content = this.domSanitizer.sanitize(SecurityContext.HTML, this.content);\n                }\n                const contents = this.quillEditor.clipboard.convert(this.content);\n                this.quillEditor.setContents(contents, 'silent');\n            }\n            this.quillEditor.history.clear();\n        }\n        // initialize disabled status based on this.disabled as default value\n        this.setDisabledState();\n        this.onEditorCreated.emit(this.quillEditor);\n        // mark model as touched if editor lost focus\n        this.quillEditor.on('selection-change', this.selectionChangeHandler);\n        // update model if text changes\n        this.quillEditor.on('text-change', this.textChangeHandler);\n    }\n    ngOnDestroy() {\n        if (this.quillEditor) {\n            this.quillEditor.off('selection-change', this.selectionChangeHandler);\n            this.quillEditor.off('text-change', this.textChangeHandler);\n        }\n    }\n    ngOnChanges(changes) {\n        if (!this.quillEditor) {\n            return;\n        }\n        // tslint:disable:no-string-literal\n        if (changes['readOnly']) {\n            this.quillEditor.enable(!changes['readOnly'].currentValue);\n        }\n        if (changes['placeholder']) {\n            this.quillEditor.root.dataset.placeholder =\n                changes['placeholder'].currentValue;\n        }\n        if (changes['style']) {\n            const currentStyling = changes['style'].currentValue;\n            const previousStyling = changes['style'].previousValue;\n            if (previousStyling) {\n                Object.keys(previousStyling).forEach((key) => {\n                    this.renderer.removeStyle(this.editorElem, key);\n                });\n            }\n            if (currentStyling) {\n                Object.keys(currentStyling).forEach((key) => {\n                    this.renderer.setStyle(this.editorElem, key, this.style[key]);\n                });\n            }\n        }\n        // tslint:enable:no-string-literal\n    }\n    writeValue(currentValue) {\n        this.content = currentValue;\n        if (this.quillEditor) {\n            if (currentValue) {\n                if (this.format === 'text') {\n                    this.quillEditor.setText(currentValue);\n                }\n                else {\n                    this.quillEditor.setContents(this.valueSetter(this.quillEditor, this.content));\n                }\n                return;\n            }\n            this.quillEditor.setText('');\n        }\n    }\n    setDisabledState(isDisabled = this.disabled) {\n        // store initial value to set appropriate disabled status after ViewInit\n        this.disabled = isDisabled;\n        if (this.quillEditor) {\n            if (isDisabled) {\n                this.quillEditor.disable();\n                this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'disabled');\n            }\n            else {\n                if (!this.readOnly) {\n                    this.quillEditor.enable();\n                }\n                this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');\n            }\n        }\n    }\n    registerOnChange(fn) {\n        this.onModelChange = fn;\n    }\n    registerOnTouched(fn) {\n        this.onModelTouched = fn;\n    }\n    validate() {\n        if (!this.quillEditor) {\n            return null;\n        }\n        const err = {};\n        let valid = true;\n        const textLength = this.quillEditor.getText().trim().length;\n        if (this.minLength && textLength && textLength < this.minLength) {\n            err.minLengthError = {\n                given: textLength,\n                minLength: this.minLength\n            };\n            valid = false;\n        }\n        if (this.maxLength && textLength > this.maxLength) {\n            err.maxLengthError = {\n                given: textLength,\n                maxLength: this.maxLength\n            };\n            valid = false;\n        }\n        if (this.required && !textLength) {\n            err.requiredError = {\n                empty: true\n            };\n            valid = false;\n        }\n        return valid ? null : err;\n    }\n};\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], QuillEditorComponent.prototype, \"format\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], QuillEditorComponent.prototype, \"theme\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], QuillEditorComponent.prototype, \"modules\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], QuillEditorComponent.prototype, \"debug\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], QuillEditorComponent.prototype, \"readOnly\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], QuillEditorComponent.prototype, \"placeholder\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], QuillEditorComponent.prototype, \"maxLength\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Number)\n], QuillEditorComponent.prototype, \"minLength\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], QuillEditorComponent.prototype, \"required\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Array)\n], QuillEditorComponent.prototype, \"formats\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], QuillEditorComponent.prototype, \"customToolbarPosition\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], QuillEditorComponent.prototype, \"sanitize\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], QuillEditorComponent.prototype, \"style\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], QuillEditorComponent.prototype, \"strict\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], QuillEditorComponent.prototype, \"scrollingContainer\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], QuillEditorComponent.prototype, \"bounds\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Array)\n], QuillEditorComponent.prototype, \"customOptions\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", String)\n], QuillEditorComponent.prototype, \"trackChanges\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Boolean)\n], QuillEditorComponent.prototype, \"preserveWhitespace\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], QuillEditorComponent.prototype, \"onEditorCreated\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], QuillEditorComponent.prototype, \"onContentChanged\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], QuillEditorComponent.prototype, \"onSelectionChanged\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], QuillEditorComponent.prototype, \"onFocus\", void 0);\n__decorate([\n    Output(),\n    __metadata(\"design:type\", EventEmitter)\n], QuillEditorComponent.prototype, \"onBlur\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], QuillEditorComponent.prototype, \"valueGetter\", void 0);\n__decorate([\n    Input(),\n    __metadata(\"design:type\", Object)\n], QuillEditorComponent.prototype, \"valueSetter\", void 0);\nQuillEditorComponent = QuillEditorComponent_1 = __decorate([\n    Component({\n        encapsulation: ViewEncapsulation.None,\n        providers: [\n            {\n                multi: true,\n                provide: NG_VALUE_ACCESSOR,\n                useExisting: forwardRef(() => QuillEditorComponent_1)\n            },\n            {\n                multi: true,\n                provide: NG_VALIDATORS,\n                useExisting: forwardRef(() => QuillEditorComponent_1)\n            }\n        ],\n        selector: 'quill-editor',\n        template: `\n  <ng-content select=\"[quill-editor-toolbar]\"></ng-content>\n`\n    }),\n    __param(2, Inject(DOCUMENT)),\n    __param(3, Inject(PLATFORM_ID)),\n    __param(6, Inject(QUILL_CONFIG_TOKEN)),\n    __metadata(\"design:paramtypes\", [ElementRef,\n        DomSanitizer, Object, Object,\n        Renderer2,\n        NgZone, Object])\n], QuillEditorComponent);\n\nvar QuillModule_1;\nconst ɵ0 = { modules: defaultModules };\nlet QuillModule = QuillModule_1 = class QuillModule {\n    static forRoot(config) {\n        return {\n            ngModule: QuillModule_1,\n            providers: [\n                {\n                    provide: QUILL_CONFIG_TOKEN,\n                    // tslint:disable-next-line:only-arrow-functions\n                    useValue: config || { modules: defaultModules }\n                }\n            ]\n        };\n    }\n};\nQuillModule = QuillModule_1 = __decorate([\n    NgModule({\n        declarations: [\n            QuillEditorComponent\n        ],\n        exports: [QuillEditorComponent],\n        imports: [],\n        providers: [\n            {\n                provide: QUILL_CONFIG_TOKEN,\n                useValue: ɵ0\n            }\n        ]\n    })\n], QuillModule);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { QUILL_CONFIG_TOKEN, QuillEditorComponent, QuillModule, defaultModules, ɵ0 };\n"]}
{"version":3,"sources":["/Users/albaortegaflores/Documentos/TFM/code/web/node_modules/@angular-material-extensions/google-maps-autocomplete/fesm2015/angular-material-extensions-google-maps-autocomplete.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmHC,cAWC;;;;;;;;;;;;;gDAEoD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAwLrD,iSAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAwBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsOD,yiBAQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2MD,ojBAMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuDD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAwBC","file":"angular-material-extensions-google-maps-autocomplete.js","sourcesContent":["import { Directive, forwardRef, EventEmitter, Component, NgZone, ViewChild, Input, Output, Inject, PLATFORM_ID, ElementRef, NgModule } from '@angular/core';\nimport { NG_VALIDATORS, FormControl, Validators, FormBuilder, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { MapsAPILoader } from '@agm/core';\nimport { animation, style, animate, trigger, transition, useAnimation, state, query, stagger, animateChild } from '@angular/animations';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { FlexLayoutModule } from '@angular/flex-layout';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatIconModule } from '@angular/material/icon';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/interfaces/germand.address.interface.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @author Anthony Nahas\n * \\@since 23.12.19\n * @version 1.0\n * @record\n */\nfunction GermanAddress() { }\nif (false) {\n    /** @type {?|undefined} */\n    GermanAddress.prototype.id;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.gmID;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.placeID;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.name;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.icon;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.displayAddress;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.postalCode;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.streetNumber;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.streetName;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.sublocality;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.locality;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.state;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.country;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.vicinity;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.url;\n    /** @type {?|undefined} */\n    GermanAddress.prototype.geoLocation;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/interfaces/location.interface.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction Location() { }\nif (false) {\n    /** @type {?} */\n    Location.prototype.latitude;\n    /** @type {?} */\n    Location.prototype.longitude;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/interfaces/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/directives/address-validator/mat-address-validator.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts\nclass MatValidateAddressDirective {\n    constructor() {\n    }\n    /**\n     * @return {?}\n     */\n    validate() {\n        return (/**\n         * @param {?} control\n         * @return {?}\n         */\n        (control) => {\n            return this.address ? null : {\n                validateAddress: {\n                    valid: false\n                }\n            };\n        });\n    }\n    /**\n     * @param {?} eventEmitter\n     * @return {?}\n     */\n    subscribe(eventEmitter) {\n        this.subscription = eventEmitter.subscribe((/**\n         * @param {?} address\n         * @return {?}\n         */\n        (address) => {\n            this.address = address;\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    unsubscribe() {\n        this.subscription.unsubscribe();\n    }\n    /**\n     * @return {?}\n     */\n    get address() {\n        return this._address;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set address(value) {\n        this._address = value;\n    }\n}\nMatValidateAddressDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',\n                providers: [\n                    { provide: NG_VALIDATORS, useExisting: forwardRef((/**\n                         * @return {?}\n                         */\n                        () => MatValidateAddressDirective)), multi: true }\n                ]\n            },] }\n];\n/** @nocollapse */\nMatValidateAddressDirective.ctorParameters = () => [];\nif (false) {\n    /** @type {?} */\n    MatValidateAddressDirective.prototype.subscription;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatValidateAddressDirective.prototype._address;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/component/mat-google-maps-autocomplete.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {string} */\nconst Appearance = {\n    STANDARD: \"standard\",\n    FILL: \"fill\",\n    OUTLINE: \"outline\",\n    LEGACY: \"legacy\",\n};\nclass MatGoogleMapsAutocompleteComponent {\n    /**\n     * @param {?} mapsAPILoader\n     * @param {?} ngZone\n     */\n    constructor(mapsAPILoader, ngZone) {\n        this.mapsAPILoader = mapsAPILoader;\n        this.ngZone = ngZone;\n        this.addressLabelText = 'Address';\n        this.placeholderText = 'Please enter the address';\n        this.requiredErrorText = 'The address is required';\n        this.invalidErrorText = 'The address is not valid';\n        this.appearance = Appearance.STANDARD;\n        this.autoCompleteOptions = {};\n        this.onChange = new EventEmitter();\n        this.onAutocompleteSelected = new EventEmitter();\n        this.onGermanAddressMapped = new EventEmitter();\n        this.onLocationSelected = new EventEmitter();\n        this.onNewPlaceResult = new EventEmitter();\n        this.addressValidator = new MatValidateAddressDirective();\n        this.addressSearchControl = new FormControl({ value: null }, Validators.compose([\n            Validators.required,\n            this.addressValidator.validate()\n        ]));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.addressValidator.subscribe(this.onNewPlaceResult);\n        /** @type {?} */\n        const options = {\n            // types: ['address'],\n            // componentRestrictions: {country: this.country},\n            placeIdOnly: this.placeIdOnly,\n            strictBounds: this.strictBounds,\n            // types: this.types,\n            type: this.type\n        };\n        // tslint:disable-next-line:no-unused-expression\n        this.country ? options.componentRestrictions = { country: this.country } : null;\n        // tslint:disable-next-line:no-unused-expression\n        this.country ? options.types = this.types : null;\n        this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n        this.initGoogleMapsAutocomplete();\n    }\n    /**\n     * @return {?}\n     */\n    initGoogleMapsAutocomplete() {\n        this.mapsAPILoader\n            .load()\n            .then((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);\n            autocomplete.addListener('place_changed', (/**\n             * @return {?}\n             */\n            () => {\n                this.ngZone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    // get the place result\n                    /** @type {?} */\n                    const place = autocomplete.getPlace();\n                    /** @type {?} */\n                    const germanAddress = {\n                        gmID: place.id,\n                        icon: place.icon,\n                        url: place.url,\n                        placeID: place.place_id,\n                        displayAddress: place.formatted_address,\n                        name: place.name,\n                        vicinity: place.vicinity,\n                        locality: {},\n                        state: {},\n                        country: {},\n                        geoLocation: { latitude: -1, longitude: -1 },\n                    };\n                    if (place.geometry && place.geometry.location) {\n                        germanAddress.geoLocation.latitude = place.geometry.location.lat();\n                        germanAddress.geoLocation.longitude = place.geometry.location.lng();\n                    }\n                    place.address_components.forEach((/**\n                     * @param {?} value\n                     * @return {?}\n                     */\n                    value => {\n                        if (value.types.indexOf('street_number') > -1) {\n                            germanAddress.streetNumber = value.short_name;\n                        }\n                        if (value.types.indexOf('route') > -1) {\n                            germanAddress.streetName = value.long_name;\n                        }\n                        if (value.types.indexOf('postal_code') > -1) {\n                            germanAddress.postalCode = Number(value.short_name);\n                        }\n                        if (value.types.indexOf('sublocality') > -1) {\n                            germanAddress.sublocality = value.long_name;\n                        }\n                        if (value.types.indexOf('locality') > -1) {\n                            germanAddress.locality.long = value.long_name;\n                            germanAddress.locality.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_1') > -1) {\n                            germanAddress.state.long = value.long_name;\n                            germanAddress.state.short = value.short_name;\n                        }\n                        if (value.types.indexOf('country') > -1) {\n                            germanAddress.country.long = value.long_name;\n                            germanAddress.country.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_3') > -1) {\n                            germanAddress.locality.short = value.short_name;\n                        }\n                    }));\n                    this.onGermanAddressMapped.emit(germanAddress);\n                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {\n                        // place result is not valid\n                        return;\n                    }\n                    else {\n                        // show dialog to select a address from the input\n                        // emit failed event\n                    }\n                    this.address = place.formatted_address;\n                    this.onAutocompleteSelected.emit(place);\n                    // console.log('onAutocompleteSelected -> ', place);\n                    this.onLocationSelected.emit({\n                        latitude: place.geometry.location.lat(),\n                        longitude: place.geometry.location.lng()\n                    });\n                }));\n            }));\n        }))\n            .catch((/**\n         * @param {?} err\n         * @return {?}\n         */\n        (err) => console.log(err)));\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    onQuery(event) {\n        // console.log('onChange()', event);\n        this.onChange.emit(this.address);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    resetAddress() {\n        this.address = null;\n        this.addressSearchControl.updateValueAndValidity();\n    }\n}\nMatGoogleMapsAutocompleteComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-google-maps-autocomplete',\n                exportAs: 'matGoogleMapsAutocomplete',\n                template: \"<mat-form-field class=\\\"full-width\\\" [appearance]=\\\"appearance\\\">\\n  <mat-label>{{addressLabelText}}</mat-label>\\n  <input matInput\\n         [(ngModel)]=\\\"address\\\"\\n         (change)=\\\"onQuery($event)\\\"\\n         placeholder=\\\"{{placeholderText}}\\\"\\n         class=\\\"form-control\\\"\\n         #search\\n         MatValidateAddress\\n         required>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('required')\\\">\\n    {{requiredErrorText}}\\n  </mat-error>\\n  <mat-error *ngIf=\\\"addressSearchControl.hasError('validateAddress')\\\">\\n    {{invalidErrorText}}\\n  </mat-error>\\n</mat-form-field>\\n\",\n                styles: [\".full-width{width:100%}\"]\n            }] }\n];\n/** @nocollapse */\nMatGoogleMapsAutocompleteComponent.ctorParameters = () => [\n    { type: MapsAPILoader },\n    { type: NgZone }\n];\nMatGoogleMapsAutocompleteComponent.propDecorators = {\n    searchElementRef: [{ type: ViewChild, args: ['search', { static: false },] }],\n    addressLabelText: [{ type: Input }],\n    placeholderText: [{ type: Input }],\n    requiredErrorText: [{ type: Input }],\n    invalidErrorText: [{ type: Input }],\n    appearance: [{ type: Input }],\n    address: [{ type: Input }],\n    country: [{ type: Input }],\n    placeIdOnly: [{ type: Input }],\n    strictBounds: [{ type: Input }],\n    types: [{ type: Input }],\n    type: [{ type: Input }],\n    autoCompleteOptions: [{ type: Input }],\n    onChange: [{ type: Output }],\n    onAutocompleteSelected: [{ type: Output }],\n    onGermanAddressMapped: [{ type: Output }],\n    onLocationSelected: [{ type: Output }]\n};\nif (false) {\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.searchElementRef;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.addressLabelText;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.placeholderText;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.requiredErrorText;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.invalidErrorText;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.appearance;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.address;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.country;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.placeIdOnly;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.strictBounds;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.types;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.type;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.autoCompleteOptions;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.onChange;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.onAutocompleteSelected;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.onGermanAddressMapped;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.onLocationSelected;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatGoogleMapsAutocompleteComponent.prototype.onNewPlaceResult;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatGoogleMapsAutocompleteComponent.prototype.addressValidator;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteComponent.prototype.addressSearchControl;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatGoogleMapsAutocompleteComponent.prototype.mapsAPILoader;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatGoogleMapsAutocompleteComponent.prototype.ngZone;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/helpers/parser.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} placeResult\n * @return {?}\n */\nfunction parseGermanAddress(placeResult) {\n    /** @type {?} */\n    const germanAddress = {\n        gmID: placeResult.id,\n        icon: placeResult.icon,\n        url: placeResult.url,\n        placeID: placeResult.place_id,\n        displayAddress: placeResult.formatted_address,\n        name: placeResult.name,\n        vicinity: placeResult.vicinity,\n        locality: {},\n        state: {},\n        country: {},\n        geoLocation: { latitude: -1, longitude: -1 },\n    };\n    if (placeResult.geometry && placeResult.geometry.location) {\n        germanAddress.geoLocation.latitude = placeResult.geometry.location.lat();\n        germanAddress.geoLocation.longitude = placeResult.geometry.location.lng();\n    }\n    if (placeResult.address_components && placeResult.address_components.length > 0) {\n        placeResult.address_components.forEach((/**\n         * @param {?} value\n         * @return {?}\n         */\n        value => {\n            if (value.types.indexOf('street_number') > -1) {\n                germanAddress.streetNumber = value.short_name;\n            }\n            if (value.types.indexOf('route') > -1) {\n                germanAddress.streetName = value.long_name;\n            }\n            if (value.types.indexOf('postal_code') > -1) {\n                germanAddress.postalCode = Number(value.short_name);\n            }\n            if (value.types.indexOf('sublocality') > -1) {\n                germanAddress.sublocality = value.long_name;\n            }\n            if (value.types.indexOf('locality') > -1) {\n                germanAddress.locality.long = value.long_name;\n                germanAddress.locality.short = value.short_name;\n            }\n            if (value.types.indexOf('administrative_area_level_1') > -1) {\n                germanAddress.state.long = value.long_name;\n                germanAddress.state.short = value.short_name;\n            }\n            if (value.types.indexOf('country') > -1) {\n                germanAddress.country.long = value.long_name;\n                germanAddress.country.short = value.short_name;\n            }\n            if (value.types.indexOf('administrative_area_level_3') > -1) {\n                germanAddress.locality.short = value.short_name;\n            }\n        }));\n    }\n    return germanAddress;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/animations/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst customAnimation = animation([\n    style({\n        opacity: '{{opacity}}',\n        transform: 'scale({{scale}}) translate3d({{x}}, {{y}}, {{z}})'\n    }),\n    animate('{{duration}} {{delay}} cubic-bezier(0.0, 0.0, 0.2, 1)', style('*'))\n], {\n    params: {\n        duration: '200ms',\n        delay: '0ms',\n        opacity: '0',\n        scale: '1',\n        x: '0',\n        y: '0',\n        z: '0'\n    }\n});\n/** @type {?} */\nconst InputAnimations = [\n    trigger('animate', [transition('void => *', [useAnimation(customAnimation)])]),\n    trigger('animateStagger', [\n        state('50', style('*')),\n        state('100', style('*')),\n        state('200', style('*')),\n        transition('void => 50', query('@*', [stagger('50ms', [animateChild()])], { optional: true })),\n        transition('void => 100', query('@*', [stagger('100ms', [animateChild()])], { optional: true })),\n        transition('void => 200', query('@*', [stagger('200ms', [animateChild()])], { optional: true }))\n    ]),\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatSearchGoogleMapsAutocompleteComponent {\n    /**\n     * @param {?} formBuilder\n     */\n    constructor(formBuilder) {\n        this.formBuilder = formBuilder;\n        this.appearance = Appearance.STANDARD;\n        this.searchAddressLabel = 'Search Address';\n        this.streetNameLabel = 'Street';\n        this.streetNumberLabel = 'Nr.';\n        this.postalCodeLabel = 'PLZ';\n        this.localityLabel = 'Locality';\n        this.vicinityLabel = 'Vicinity';\n        this.onGermanAddressMapped = new EventEmitter();\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.addressFormGroup = this.createAddressFormGroup();\n    }\n    /**\n     * @return {?}\n     */\n    createAddressFormGroup() {\n        return this.formBuilder.group({\n            streetName: [this.value && this.value.streetName ? this.value.streetName : null, Validators.required],\n            streetNumber: [this.value && this.value.streetNumber ? this.value.streetNumber : null, Validators.required],\n            postalCode: [this.value && this.value.postalCode ? this.value.postalCode : null, Validators.required],\n            vicinity: [this.value && this.value.vicinity ? this.value.vicinity : null],\n            locality: this.formBuilder.group({\n                long: [this.value && this.value.locality && this.value.locality.long ? this.value.locality.long : null, Validators.required],\n            }),\n        });\n    }\n    /**\n     * @param {?} $event\n     * @return {?}\n     */\n    syncAutoComplete($event) {\n        if (this.germanAddress) {\n            this.addressFormGroup.reset();\n        }\n        /** @type {?} */\n        const germanAddress = parseGermanAddress($event);\n        this.germanAddress = germanAddress;\n        if (germanAddress.vicinity) {\n            this.addressFormGroup.get('vicinity').patchValue(germanAddress.vicinity);\n        }\n        if (germanAddress.streetName) {\n            this.addressFormGroup.get('streetName').patchValue(germanAddress.streetName);\n        }\n        if (germanAddress.streetNumber) {\n            this.addressFormGroup.get('streetNumber').patchValue(germanAddress.streetNumber);\n        }\n        if (germanAddress.postalCode) {\n            this.addressFormGroup.get('postalCode').patchValue(germanAddress.postalCode);\n        }\n        if (germanAddress.locality && germanAddress.locality.long) {\n            this.addressFormGroup.get('locality.long').patchValue(germanAddress.locality.long);\n        }\n        this.onGermanAddressMapped.emit(germanAddress);\n    }\n}\nMatSearchGoogleMapsAutocompleteComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'mat-search-google-maps-autocomplete',\n                template: \"<div fxLayout=\\\"column\\\">\\n  <div *ngIf=\\\"!disableSearch\\\" fxFlex=\\\"100\\\">\\n    <!--search address-->\\n    <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n      <mat-label>{{searchAddressLabel}}</mat-label>\\n      <input\\n        (onAutocompleteSelected)=\\\"syncAutoComplete($event)\\\"\\n        [country]=\\\"country\\\"\\n        [placeIdOnly]=\\\"placeIdOnly\\\"\\n        [strictBounds]=\\\"strictBounds\\\"\\n        [types]=\\\"types\\\"\\n        [type]=\\\"type\\\"\\n        matGoogleMapsAutocomplete\\n        matInput\\n        required\\n      />\\n      <mat-icon color=\\\"primary\\\" matSuffix>search</mat-icon>\\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n    </mat-form-field>\\n  </div>\\n\\n  <form [formGroup]=\\\"addressFormGroup\\\" fxFlex fxLayoutGap=\\\"10px\\\">\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"80\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNameLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetName\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{streetNumberLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"streetNumber\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n    </div>\\n    <div fxLayout=\\\"row\\\" fxLayoutGap=\\\"10px\\\">\\n      <mat-form-field fxFlex=\\\"20\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{postalCodeLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          formControlName=\\\"postalCode\\\"\\n          matInput\\n          required\\n        />\\n        <!--        <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>-->\\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n      </mat-form-field>\\n      <mat-form-field *ngIf=\\\"showVicinity\\\" fxFlex=\\\"auto\\\"\\n                      [appearance]=\\\"appearance\\\"\\n                      [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n        <mat-label>{{vicinityLabel}}</mat-label>\\n        <input\\n          [readonly]=\\\"readonly\\\"\\n          matInput\\n          formControlName=\\\"vicinity\\\"\\n        />\\n      </mat-form-field>\\n      <div formGroupName=\\\"locality\\\" fxFlex=\\\"auto\\\">\\n        <mat-form-field fxFlex=\\\"auto\\\" [appearance]=\\\"appearance\\\" [@animate]=\\\"{ value: '*', params: { y: '100%' } }\\\">\\n          <mat-label>{{localityLabel}}</mat-label>\\n          <input\\n            [readonly]=\\\"readonly\\\"\\n            formControlName=\\\"long\\\"\\n            matInput\\n            required\\n          />\\n          <mat-icon color=\\\"primary\\\" matSuffix>add_location</mat-icon>\\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\\n        </mat-form-field>\\n      </div>\\n    </div>\\n  </form>\\n</div>\\n\",\n                animations: InputAnimations,\n                styles: [\"\"]\n            }] }\n];\n/** @nocollapse */\nMatSearchGoogleMapsAutocompleteComponent.ctorParameters = () => [\n    { type: FormBuilder }\n];\nMatSearchGoogleMapsAutocompleteComponent.propDecorators = {\n    appearance: [{ type: Input }],\n    searchAddressLabel: [{ type: Input }],\n    streetNameLabel: [{ type: Input }],\n    streetNumberLabel: [{ type: Input }],\n    postalCodeLabel: [{ type: Input }],\n    localityLabel: [{ type: Input }],\n    vicinityLabel: [{ type: Input }],\n    showVicinity: [{ type: Input }],\n    country: [{ type: Input }],\n    placeIdOnly: [{ type: Input }],\n    strictBounds: [{ type: Input }],\n    types: [{ type: Input }],\n    type: [{ type: Input }],\n    readonly: [{ type: Input }],\n    disableSearch: [{ type: Input }],\n    value: [{ type: Input }],\n    onGermanAddressMapped: [{ type: Output }]\n};\nif (false) {\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.appearance;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.searchAddressLabel;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.streetNameLabel;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.streetNumberLabel;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.postalCodeLabel;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.localityLabel;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.vicinityLabel;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.showVicinity;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.country;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.placeIdOnly;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.strictBounds;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.types;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.type;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.readonly;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.disableSearch;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.value;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.onGermanAddressMapped;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.germanAddress;\n    /** @type {?} */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.addressFormGroup;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatSearchGoogleMapsAutocompleteComponent.prototype.formBuilder;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/component/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/directives/mat-google-maps-autocomplete.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatGoogleMapsAutocompleteDirective {\n    /**\n     * @param {?} platformId\n     * @param {?} elemRef\n     * @param {?} mapsAPILoader\n     * @param {?} ngZone\n     */\n    constructor(platformId, elemRef, mapsAPILoader, ngZone) {\n        this.platformId = platformId;\n        this.elemRef = elemRef;\n        this.mapsAPILoader = mapsAPILoader;\n        this.ngZone = ngZone;\n        this.autoCompleteOptions = {};\n        this.onChange = new EventEmitter();\n        this.onAutocompleteSelected = new EventEmitter();\n        this.onGermanAddressMapped = new EventEmitter();\n        this.onLocationSelected = new EventEmitter();\n        this.onNewPlaceResult = new EventEmitter();\n        this.addressValidator = new MatValidateAddressDirective();\n        this.addressSearchControl = new FormControl({ value: null }, Validators.compose([\n            Validators.required,\n            this.addressValidator.validate()\n        ]));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        if (isPlatformBrowser(this.platformId)) {\n            this.addressValidator.subscribe(this.onNewPlaceResult);\n            /** @type {?} */\n            const options = {\n                // types: ['address'],\n                // componentRestrictions: {country: this.country},\n                placeIdOnly: this.placeIdOnly,\n                strictBounds: this.strictBounds,\n                // types: this.types,\n                type: this.type\n            };\n            // tslint:disable-next-line:no-unused-expression\n            this.country ? options.componentRestrictions = { country: this.country } : null;\n            // tslint:disable-next-line:no-unused-expression\n            this.country ? options.types = this.types : null;\n            this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);\n            this.initGoogleMapsAutocomplete();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    initGoogleMapsAutocomplete() {\n        this.mapsAPILoader\n            .load()\n            .then((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement, this.autoCompleteOptions);\n            autocomplete.addListener('place_changed', (/**\n             * @return {?}\n             */\n            () => {\n                this.ngZone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    // get the place result\n                    /** @type {?} */\n                    const place = autocomplete.getPlace();\n                    /** @type {?} */\n                    const germanAddress = {\n                        gmID: place.id,\n                        icon: place.icon,\n                        url: place.url,\n                        placeID: place.place_id,\n                        displayAddress: place.formatted_address,\n                        name: place.name,\n                        vicinity: place.vicinity,\n                        locality: {},\n                        state: {},\n                        country: {},\n                        geoLocation: { latitude: -1, longitude: -1 },\n                    };\n                    if (place.geometry && place.geometry.location) {\n                        germanAddress.geoLocation.latitude = place.geometry.location.lat();\n                        germanAddress.geoLocation.longitude = place.geometry.location.lng();\n                    }\n                    place.address_components.forEach((/**\n                     * @param {?} value\n                     * @return {?}\n                     */\n                    value => {\n                        if (value.types.indexOf('street_number') > -1) {\n                            germanAddress.streetNumber = value.short_name;\n                        }\n                        if (value.types.indexOf('route') > -1) {\n                            germanAddress.streetName = value.long_name;\n                        }\n                        if (value.types.indexOf('postal_code') > -1) {\n                            germanAddress.postalCode = Number(value.short_name);\n                        }\n                        if (value.types.indexOf('sublocality') > -1) {\n                            germanAddress.sublocality = value.long_name;\n                        }\n                        if (value.types.indexOf('locality') > -1) {\n                            germanAddress.locality.long = value.long_name;\n                            germanAddress.locality.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_1') > -1) {\n                            germanAddress.state.long = value.long_name;\n                            germanAddress.state.short = value.short_name;\n                        }\n                        if (value.types.indexOf('country') > -1) {\n                            germanAddress.country.long = value.long_name;\n                            germanAddress.country.short = value.short_name;\n                        }\n                        if (value.types.indexOf('administrative_area_level_3') > -1) {\n                            germanAddress.locality.short = value.short_name;\n                        }\n                    }));\n                    this.onGermanAddressMapped.emit(germanAddress);\n                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {\n                        // place result is not valid\n                        return;\n                    }\n                    else {\n                        // show dialog to select a address from the input\n                        // emit failed event\n                    }\n                    this.address = place.formatted_address;\n                    this.onAutocompleteSelected.emit(place);\n                    this.onLocationSelected.emit({\n                        latitude: place.geometry.location.lat(),\n                        longitude: place.geometry.location.lng()\n                    });\n                }));\n            }));\n        }))\n            .catch((/**\n         * @param {?} err\n         * @return {?}\n         */\n        (err) => console.log(err)));\n    }\n}\nMatGoogleMapsAutocompleteDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[matGoogleMapsAutocomplete]',\n                exportAs: 'matGoogleMapsAutocomplete',\n            },] }\n];\n/** @nocollapse */\nMatGoogleMapsAutocompleteDirective.ctorParameters = () => [\n    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: ElementRef },\n    { type: MapsAPILoader },\n    { type: NgZone }\n];\nMatGoogleMapsAutocompleteDirective.propDecorators = {\n    address: [{ type: Input }],\n    country: [{ type: Input }],\n    placeIdOnly: [{ type: Input }],\n    strictBounds: [{ type: Input }],\n    types: [{ type: Input }],\n    type: [{ type: Input }],\n    autoCompleteOptions: [{ type: Input }],\n    onChange: [{ type: Output }],\n    onAutocompleteSelected: [{ type: Output }],\n    onGermanAddressMapped: [{ type: Output }],\n    onLocationSelected: [{ type: Output }]\n};\nif (false) {\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.address;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.country;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.placeIdOnly;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.strictBounds;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.types;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.type;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.autoCompleteOptions;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.onChange;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.onAutocompleteSelected;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.onGermanAddressMapped;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.onLocationSelected;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatGoogleMapsAutocompleteDirective.prototype.onNewPlaceResult;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatGoogleMapsAutocompleteDirective.prototype.addressValidator;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.addressSearchControl;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.platformId;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.elemRef;\n    /** @type {?} */\n    MatGoogleMapsAutocompleteDirective.prototype.mapsAPILoader;\n    /**\n     * @type {?}\n     * @private\n     */\n    MatGoogleMapsAutocompleteDirective.prototype.ngZone;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/mat-google-maps-autocomplete.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MatGoogleMapsAutocompleteModule {\n}\nMatGoogleMapsAutocompleteModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [\n                    CommonModule,\n                    FormsModule,\n                    ReactiveFormsModule,\n                    FlexLayoutModule,\n                    MatInputModule,\n                    MatIconModule\n                ],\n                exports: [\n                    MatGoogleMapsAutocompleteComponent,\n                    MatGoogleMapsAutocompleteDirective,\n                    MatValidateAddressDirective,\n                    MatSearchGoogleMapsAutocompleteComponent\n                ],\n                declarations: [\n                    MatGoogleMapsAutocompleteComponent,\n                    MatGoogleMapsAutocompleteDirective,\n                    MatValidateAddressDirective,\n                    MatSearchGoogleMapsAutocompleteComponent\n                ]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-material-extensions-google-maps-autocomplete.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { Appearance, MatGoogleMapsAutocompleteComponent, MatGoogleMapsAutocompleteDirective, MatGoogleMapsAutocompleteModule, MatSearchGoogleMapsAutocompleteComponent, MatValidateAddressDirective, MatGoogleMapsAutocompleteComponent as ɵa, MatSearchGoogleMapsAutocompleteComponent as ɵb, InputAnimations as ɵc };\n"]}
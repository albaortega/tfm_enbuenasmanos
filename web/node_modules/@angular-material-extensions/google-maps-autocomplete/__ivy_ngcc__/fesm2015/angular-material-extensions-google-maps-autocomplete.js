import { Directive, forwardRef, EventEmitter, Component, NgZone, ViewChild, Input, Output, Inject, PLATFORM_ID, ElementRef, NgModule } from '@angular/core';
import { NG_VALIDATORS, FormControl, Validators, FormBuilder, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MapsAPILoader } from '@agm/core';
import { animation, style, animate, trigger, transition, useAnimation, state, query, stagger, animateChild } from '@angular/animations';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { FlexLayoutModule } from '@angular/flex-layout';
import { MatInputModule } from '@angular/material/input';
import { MatIconModule } from '@angular/material/icon';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/interfaces/germand.address.interface.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @author Anthony Nahas
 * \@since 23.12.19
 * @version 1.0
 * @record
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@agm/core';
import * as ɵngcc2 from '@angular/material/form-field';
import * as ɵngcc3 from '@angular/material/input';
import * as ɵngcc4 from '@angular/forms';
import * as ɵngcc5 from '@angular/common';
import * as ɵngcc6 from '@angular/flex-layout/flex';
import * as ɵngcc7 from '@angular/material/icon';

const _c0 = ["search"];
function MatGoogleMapsAutocompleteComponent_mat_error_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-error");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r293 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r293.requiredErrorText, " ");
} }
function MatGoogleMapsAutocompleteComponent_mat_error_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-error");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r294 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r294.invalidErrorText, " ");
} }
const _c1 = function () { return { y: "100%" }; };
const _c2 = function (a1) { return { value: "*", params: a1 }; };
function MatSearchGoogleMapsAutocompleteComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r298 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵelementStart(1, "mat-form-field", 11);
    ɵngcc0.ɵɵelementStart(2, "mat-label");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "input", 15);
    ɵngcc0.ɵɵlistener("onAutocompleteSelected", function MatSearchGoogleMapsAutocompleteComponent_div_1_Template_input_onAutocompleteSelected_4_listener($event) { ɵngcc0.ɵɵrestoreView(_r298); const ctx_r297 = ɵngcc0.ɵɵnextContext(); return ctx_r297.syncAutoComplete($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "mat-icon", 13);
    ɵngcc0.ɵɵtext(6, "search");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r295 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("appearance", ctx_r295.appearance)("@animate", ɵngcc0.ɵɵpureFunction1(9, _c2, ɵngcc0.ɵɵpureFunction0(8, _c1)));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r295.searchAddressLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("country", ctx_r295.country)("placeIdOnly", ctx_r295.placeIdOnly)("strictBounds", ctx_r295.strictBounds)("types", ctx_r295.types)("type", ctx_r295.type);
} }
function MatSearchGoogleMapsAutocompleteComponent_mat_form_field_17_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-form-field", 11);
    ɵngcc0.ɵɵelementStart(1, "mat-label");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "input", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r296 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("appearance", ctx_r296.appearance)("@animate", ɵngcc0.ɵɵpureFunction1(5, _c2, ɵngcc0.ɵɵpureFunction0(4, _c1)));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r296.vicinityLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("readonly", ctx_r296.readonly);
} }
function GermanAddress() { }
if (false) {
    /** @type {?|undefined} */
    GermanAddress.prototype.id;
    /** @type {?|undefined} */
    GermanAddress.prototype.gmID;
    /** @type {?|undefined} */
    GermanAddress.prototype.placeID;
    /** @type {?|undefined} */
    GermanAddress.prototype.name;
    /** @type {?|undefined} */
    GermanAddress.prototype.icon;
    /** @type {?|undefined} */
    GermanAddress.prototype.displayAddress;
    /** @type {?|undefined} */
    GermanAddress.prototype.postalCode;
    /** @type {?|undefined} */
    GermanAddress.prototype.streetNumber;
    /** @type {?|undefined} */
    GermanAddress.prototype.streetName;
    /** @type {?|undefined} */
    GermanAddress.prototype.sublocality;
    /** @type {?|undefined} */
    GermanAddress.prototype.locality;
    /** @type {?|undefined} */
    GermanAddress.prototype.state;
    /** @type {?|undefined} */
    GermanAddress.prototype.country;
    /** @type {?|undefined} */
    GermanAddress.prototype.vicinity;
    /** @type {?|undefined} */
    GermanAddress.prototype.url;
    /** @type {?|undefined} */
    GermanAddress.prototype.geoLocation;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/interfaces/location.interface.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function Location() { }
if (false) {
    /** @type {?} */
    Location.prototype.latitude;
    /** @type {?} */
    Location.prototype.longitude;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/interfaces/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/address-validator/mat-address-validator.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// https://github.com/angular/angular/blob/master/packages/forms/src/directives/validators.ts
class MatValidateAddressDirective {
    constructor() {
    }
    /**
     * @return {?}
     */
    validate() {
        return (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            return this.address ? null : {
                validateAddress: {
                    valid: false
                }
            };
        });
    }
    /**
     * @param {?} eventEmitter
     * @return {?}
     */
    subscribe(eventEmitter) {
        this.subscription = eventEmitter.subscribe((/**
         * @param {?} address
         * @return {?}
         */
        (address) => {
            this.address = address;
        }));
    }
    /**
     * @return {?}
     */
    unsubscribe() {
        this.subscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    get address() {
        return this._address;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set address(value) {
        this._address = value;
    }
}
MatValidateAddressDirective.ɵfac = function MatValidateAddressDirective_Factory(t) { return new (t || MatValidateAddressDirective)(); };
MatValidateAddressDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatValidateAddressDirective, selectors: [["", "mat-address-validate", "", "formControlName", ""], ["", "MatValidateAddress", "", "formControl", ""], ["", "MatValidateAddress", "", "ngModel", ""]], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NG_VALIDATORS, useExisting: forwardRef(( /**
                     * @return {?}
                     */() => MatValidateAddressDirective)), multi: true }
        ])] });
/** @nocollapse */
MatValidateAddressDirective.ctorParameters = () => [];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatValidateAddressDirective, [{
        type: Directive,
        args: [{
                selector: '[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]',
                providers: [
                    { provide: NG_VALIDATORS, useExisting: forwardRef(( /**
                             * @return {?}
                             */() => MatValidateAddressDirective)), multi: true }
                ]
            }]
    }], function () { return []; }, null); })();
if (false) {
    /** @type {?} */
    MatValidateAddressDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    MatValidateAddressDirective.prototype._address;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/component/mat-google-maps-autocomplete.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const Appearance = {
    STANDARD: "standard",
    FILL: "fill",
    OUTLINE: "outline",
    LEGACY: "legacy",
};
class MatGoogleMapsAutocompleteComponent {
    /**
     * @param {?} mapsAPILoader
     * @param {?} ngZone
     */
    constructor(mapsAPILoader, ngZone) {
        this.mapsAPILoader = mapsAPILoader;
        this.ngZone = ngZone;
        this.addressLabelText = 'Address';
        this.placeholderText = 'Please enter the address';
        this.requiredErrorText = 'The address is required';
        this.invalidErrorText = 'The address is not valid';
        this.appearance = Appearance.STANDARD;
        this.autoCompleteOptions = {};
        this.onChange = new EventEmitter();
        this.onAutocompleteSelected = new EventEmitter();
        this.onGermanAddressMapped = new EventEmitter();
        this.onLocationSelected = new EventEmitter();
        this.onNewPlaceResult = new EventEmitter();
        this.addressValidator = new MatValidateAddressDirective();
        this.addressSearchControl = new FormControl({ value: null }, Validators.compose([
            Validators.required,
            this.addressValidator.validate()
        ]));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.addressValidator.subscribe(this.onNewPlaceResult);
        /** @type {?} */
        const options = {
            // types: ['address'],
            // componentRestrictions: {country: this.country},
            placeIdOnly: this.placeIdOnly,
            strictBounds: this.strictBounds,
            // types: this.types,
            type: this.type
        };
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.componentRestrictions = { country: this.country } : null;
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.types = this.types : null;
        this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);
        this.initGoogleMapsAutocomplete();
    }
    /**
     * @return {?}
     */
    initGoogleMapsAutocomplete() {
        this.mapsAPILoader
            .load()
            .then((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);
            autocomplete.addListener('place_changed', (/**
             * @return {?}
             */
            () => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => {
                    // get the place result
                    /** @type {?} */
                    const place = autocomplete.getPlace();
                    /** @type {?} */
                    const germanAddress = {
                        gmID: place.id,
                        icon: place.icon,
                        url: place.url,
                        placeID: place.place_id,
                        displayAddress: place.formatted_address,
                        name: place.name,
                        vicinity: place.vicinity,
                        locality: {},
                        state: {},
                        country: {},
                        geoLocation: { latitude: -1, longitude: -1 },
                    };
                    if (place.geometry && place.geometry.location) {
                        germanAddress.geoLocation.latitude = place.geometry.location.lat();
                        germanAddress.geoLocation.longitude = place.geometry.location.lng();
                    }
                    place.address_components.forEach((/**
                     * @param {?} value
                     * @return {?}
                     */
                    value => {
                        if (value.types.indexOf('street_number') > -1) {
                            germanAddress.streetNumber = value.short_name;
                        }
                        if (value.types.indexOf('route') > -1) {
                            germanAddress.streetName = value.long_name;
                        }
                        if (value.types.indexOf('postal_code') > -1) {
                            germanAddress.postalCode = Number(value.short_name);
                        }
                        if (value.types.indexOf('sublocality') > -1) {
                            germanAddress.sublocality = value.long_name;
                        }
                        if (value.types.indexOf('locality') > -1) {
                            germanAddress.locality.long = value.long_name;
                            germanAddress.locality.short = value.short_name;
                        }
                        if (value.types.indexOf('administrative_area_level_1') > -1) {
                            germanAddress.state.long = value.long_name;
                            germanAddress.state.short = value.short_name;
                        }
                        if (value.types.indexOf('country') > -1) {
                            germanAddress.country.long = value.long_name;
                            germanAddress.country.short = value.short_name;
                        }
                        if (value.types.indexOf('administrative_area_level_3') > -1) {
                            germanAddress.locality.short = value.short_name;
                        }
                    }));
                    this.onGermanAddressMapped.emit(germanAddress);
                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {
                        // place result is not valid
                        return;
                    }
                    else {
                        // show dialog to select a address from the input
                        // emit failed event
                    }
                    this.address = place.formatted_address;
                    this.onAutocompleteSelected.emit(place);
                    // console.log('onAutocompleteSelected -> ', place);
                    this.onLocationSelected.emit({
                        latitude: place.geometry.location.lat(),
                        longitude: place.geometry.location.lng()
                    });
                }));
            }));
        }))
            .catch((/**
         * @param {?} err
         * @return {?}
         */
        (err) => console.log(err)));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onQuery(event) {
        // console.log('onChange()', event);
        this.onChange.emit(this.address);
    }
    /**
     * @private
     * @return {?}
     */
    resetAddress() {
        this.address = null;
        this.addressSearchControl.updateValueAndValidity();
    }
}
MatGoogleMapsAutocompleteComponent.ɵfac = function MatGoogleMapsAutocompleteComponent_Factory(t) { return new (t || MatGoogleMapsAutocompleteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.MapsAPILoader), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MatGoogleMapsAutocompleteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatGoogleMapsAutocompleteComponent, selectors: [["mat-google-maps-autocomplete"]], viewQuery: function MatGoogleMapsAutocompleteComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchElementRef = _t.first);
    } }, inputs: { addressLabelText: "addressLabelText", placeholderText: "placeholderText", requiredErrorText: "requiredErrorText", invalidErrorText: "invalidErrorText", appearance: "appearance", autoCompleteOptions: "autoCompleteOptions", address: "address", country: "country", placeIdOnly: "placeIdOnly", strictBounds: "strictBounds", types: "types", type: "type" }, outputs: { onChange: "onChange", onAutocompleteSelected: "onAutocompleteSelected", onGermanAddressMapped: "onGermanAddressMapped", onLocationSelected: "onLocationSelected" }, exportAs: ["matGoogleMapsAutocomplete"], decls: 7, vars: 6, consts: [[1, "full-width", 3, "appearance"], ["matInput", "", "MatValidateAddress", "", "required", "", 1, "form-control", 3, "ngModel", "placeholder", "ngModelChange", "change"], ["search", ""], [4, "ngIf"]], template: function MatGoogleMapsAutocompleteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "mat-form-field", 0);
        ɵngcc0.ɵɵelementStart(1, "mat-label");
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "input", 1, 2);
        ɵngcc0.ɵɵlistener("ngModelChange", function MatGoogleMapsAutocompleteComponent_Template_input_ngModelChange_3_listener($event) { return ctx.address = $event; })("change", function MatGoogleMapsAutocompleteComponent_Template_input_change_3_listener($event) { return ctx.onQuery($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, MatGoogleMapsAutocompleteComponent_mat_error_5_Template, 2, 1, "mat-error", 3);
        ɵngcc0.ɵɵtemplate(6, MatGoogleMapsAutocompleteComponent_mat_error_6_Template, 2, 1, "mat-error", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("appearance", ctx.appearance);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.addressLabelText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵpropertyInterpolate("placeholder", ctx.placeholderText);
        ɵngcc0.ɵɵproperty("ngModel", ctx.address);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.addressSearchControl.hasError("required"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.addressSearchControl.hasError("validateAddress"));
    } }, directives: [ɵngcc2.MatFormField, ɵngcc2.MatLabel, ɵngcc3.MatInput, ɵngcc4.DefaultValueAccessor, MatValidateAddressDirective, ɵngcc4.RequiredValidator, ɵngcc4.NgControlStatus, ɵngcc4.NgModel, ɵngcc5.NgIf, ɵngcc2.MatError], styles: [".full-width[_ngcontent-%COMP%]{width:100%}"] });
/** @nocollapse */
MatGoogleMapsAutocompleteComponent.ctorParameters = () => [
    { type: MapsAPILoader },
    { type: NgZone }
];
MatGoogleMapsAutocompleteComponent.propDecorators = {
    searchElementRef: [{ type: ViewChild, args: ['search', { static: false },] }],
    addressLabelText: [{ type: Input }],
    placeholderText: [{ type: Input }],
    requiredErrorText: [{ type: Input }],
    invalidErrorText: [{ type: Input }],
    appearance: [{ type: Input }],
    address: [{ type: Input }],
    country: [{ type: Input }],
    placeIdOnly: [{ type: Input }],
    strictBounds: [{ type: Input }],
    types: [{ type: Input }],
    type: [{ type: Input }],
    autoCompleteOptions: [{ type: Input }],
    onChange: [{ type: Output }],
    onAutocompleteSelected: [{ type: Output }],
    onGermanAddressMapped: [{ type: Output }],
    onLocationSelected: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatGoogleMapsAutocompleteComponent, [{
        type: Component,
        args: [{
                selector: 'mat-google-maps-autocomplete',
                exportAs: 'matGoogleMapsAutocomplete',
                template: "<mat-form-field class=\"full-width\" [appearance]=\"appearance\">\n  <mat-label>{{addressLabelText}}</mat-label>\n  <input matInput\n         [(ngModel)]=\"address\"\n         (change)=\"onQuery($event)\"\n         placeholder=\"{{placeholderText}}\"\n         class=\"form-control\"\n         #search\n         MatValidateAddress\n         required>\n  <mat-error *ngIf=\"addressSearchControl.hasError('required')\">\n    {{requiredErrorText}}\n  </mat-error>\n  <mat-error *ngIf=\"addressSearchControl.hasError('validateAddress')\">\n    {{invalidErrorText}}\n  </mat-error>\n</mat-form-field>\n",
                styles: [".full-width{width:100%}"]
            }]
    }], function () { return [{ type: ɵngcc1.MapsAPILoader }, { type: ɵngcc0.NgZone }]; }, { addressLabelText: [{
            type: Input
        }], placeholderText: [{
            type: Input
        }], requiredErrorText: [{
            type: Input
        }], invalidErrorText: [{
            type: Input
        }], appearance: [{
            type: Input
        }], autoCompleteOptions: [{
            type: Input
        }], onChange: [{
            type: Output
        }], onAutocompleteSelected: [{
            type: Output
        }], onGermanAddressMapped: [{
            type: Output
        }], onLocationSelected: [{
            type: Output
        }], address: [{
            type: Input
        }], searchElementRef: [{
            type: ViewChild,
            args: ['search', { static: false }]
        }], country: [{
            type: Input
        }], placeIdOnly: [{
            type: Input
        }], strictBounds: [{
            type: Input
        }], types: [{
            type: Input
        }], type: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.searchElementRef;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.addressLabelText;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.placeholderText;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.requiredErrorText;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.invalidErrorText;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.appearance;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.address;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.country;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.placeIdOnly;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.strictBounds;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.types;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.type;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.autoCompleteOptions;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.onChange;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.onAutocompleteSelected;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.onGermanAddressMapped;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.onLocationSelected;
    /**
     * @type {?}
     * @private
     */
    MatGoogleMapsAutocompleteComponent.prototype.onNewPlaceResult;
    /**
     * @type {?}
     * @private
     */
    MatGoogleMapsAutocompleteComponent.prototype.addressValidator;
    /** @type {?} */
    MatGoogleMapsAutocompleteComponent.prototype.addressSearchControl;
    /**
     * @type {?}
     * @private
     */
    MatGoogleMapsAutocompleteComponent.prototype.mapsAPILoader;
    /**
     * @type {?}
     * @private
     */
    MatGoogleMapsAutocompleteComponent.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/helpers/parser.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} placeResult
 * @return {?}
 */
function parseGermanAddress(placeResult) {
    /** @type {?} */
    const germanAddress = {
        gmID: placeResult.id,
        icon: placeResult.icon,
        url: placeResult.url,
        placeID: placeResult.place_id,
        displayAddress: placeResult.formatted_address,
        name: placeResult.name,
        vicinity: placeResult.vicinity,
        locality: {},
        state: {},
        country: {},
        geoLocation: { latitude: -1, longitude: -1 },
    };
    if (placeResult.geometry && placeResult.geometry.location) {
        germanAddress.geoLocation.latitude = placeResult.geometry.location.lat();
        germanAddress.geoLocation.longitude = placeResult.geometry.location.lng();
    }
    if (placeResult.address_components && placeResult.address_components.length > 0) {
        placeResult.address_components.forEach((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            if (value.types.indexOf('street_number') > -1) {
                germanAddress.streetNumber = value.short_name;
            }
            if (value.types.indexOf('route') > -1) {
                germanAddress.streetName = value.long_name;
            }
            if (value.types.indexOf('postal_code') > -1) {
                germanAddress.postalCode = Number(value.short_name);
            }
            if (value.types.indexOf('sublocality') > -1) {
                germanAddress.sublocality = value.long_name;
            }
            if (value.types.indexOf('locality') > -1) {
                germanAddress.locality.long = value.long_name;
                germanAddress.locality.short = value.short_name;
            }
            if (value.types.indexOf('administrative_area_level_1') > -1) {
                germanAddress.state.long = value.long_name;
                germanAddress.state.short = value.short_name;
            }
            if (value.types.indexOf('country') > -1) {
                germanAddress.country.long = value.long_name;
                germanAddress.country.short = value.short_name;
            }
            if (value.types.indexOf('administrative_area_level_3') > -1) {
                germanAddress.locality.short = value.short_name;
            }
        }));
    }
    return germanAddress;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/animations/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const customAnimation = animation([
    style({
        opacity: '{{opacity}}',
        transform: 'scale({{scale}}) translate3d({{x}}, {{y}}, {{z}})'
    }),
    animate('{{duration}} {{delay}} cubic-bezier(0.0, 0.0, 0.2, 1)', style('*'))
], {
    params: {
        duration: '200ms',
        delay: '0ms',
        opacity: '0',
        scale: '1',
        x: '0',
        y: '0',
        z: '0'
    }
});
/** @type {?} */
const InputAnimations = [
    trigger('animate', [transition('void => *', [useAnimation(customAnimation)])]),
    trigger('animateStagger', [
        state('50', style('*')),
        state('100', style('*')),
        state('200', style('*')),
        transition('void => 50', query('@*', [stagger('50ms', [animateChild()])], { optional: true })),
        transition('void => 100', query('@*', [stagger('100ms', [animateChild()])], { optional: true })),
        transition('void => 200', query('@*', [stagger('200ms', [animateChild()])], { optional: true }))
    ]),
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/component/mat-search-google-maps-autocomplete/mat-search-google-maps-autocomplete.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatSearchGoogleMapsAutocompleteComponent {
    /**
     * @param {?} formBuilder
     */
    constructor(formBuilder) {
        this.formBuilder = formBuilder;
        this.appearance = Appearance.STANDARD;
        this.searchAddressLabel = 'Search Address';
        this.streetNameLabel = 'Street';
        this.streetNumberLabel = 'Nr.';
        this.postalCodeLabel = 'PLZ';
        this.localityLabel = 'Locality';
        this.vicinityLabel = 'Vicinity';
        this.onGermanAddressMapped = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.addressFormGroup = this.createAddressFormGroup();
    }
    /**
     * @return {?}
     */
    createAddressFormGroup() {
        return this.formBuilder.group({
            streetName: [this.value && this.value.streetName ? this.value.streetName : null, Validators.required],
            streetNumber: [this.value && this.value.streetNumber ? this.value.streetNumber : null, Validators.required],
            postalCode: [this.value && this.value.postalCode ? this.value.postalCode : null, Validators.required],
            vicinity: [this.value && this.value.vicinity ? this.value.vicinity : null],
            locality: this.formBuilder.group({
                long: [this.value && this.value.locality && this.value.locality.long ? this.value.locality.long : null, Validators.required],
            }),
        });
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    syncAutoComplete($event) {
        if (this.germanAddress) {
            this.addressFormGroup.reset();
        }
        /** @type {?} */
        const germanAddress = parseGermanAddress($event);
        this.germanAddress = germanAddress;
        if (germanAddress.vicinity) {
            this.addressFormGroup.get('vicinity').patchValue(germanAddress.vicinity);
        }
        if (germanAddress.streetName) {
            this.addressFormGroup.get('streetName').patchValue(germanAddress.streetName);
        }
        if (germanAddress.streetNumber) {
            this.addressFormGroup.get('streetNumber').patchValue(germanAddress.streetNumber);
        }
        if (germanAddress.postalCode) {
            this.addressFormGroup.get('postalCode').patchValue(germanAddress.postalCode);
        }
        if (germanAddress.locality && germanAddress.locality.long) {
            this.addressFormGroup.get('locality.long').patchValue(germanAddress.locality.long);
        }
        this.onGermanAddressMapped.emit(germanAddress);
    }
}
MatSearchGoogleMapsAutocompleteComponent.ɵfac = function MatSearchGoogleMapsAutocompleteComponent_Factory(t) { return new (t || MatSearchGoogleMapsAutocompleteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.FormBuilder)); };
MatSearchGoogleMapsAutocompleteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatSearchGoogleMapsAutocompleteComponent, selectors: [["mat-search-google-maps-autocomplete"]], inputs: { appearance: "appearance", searchAddressLabel: "searchAddressLabel", streetNameLabel: "streetNameLabel", streetNumberLabel: "streetNumberLabel", postalCodeLabel: "postalCodeLabel", localityLabel: "localityLabel", vicinityLabel: "vicinityLabel", showVicinity: "showVicinity", country: "country", placeIdOnly: "placeIdOnly", strictBounds: "strictBounds", types: "types", type: "type", readonly: "readonly", disableSearch: "disableSearch", value: "value" }, outputs: { onGermanAddressMapped: "onGermanAddressMapped" }, decls: 25, vars: 31, consts: [["fxLayout", "column"], ["fxFlex", "100", 4, "ngIf"], ["fxFlex", "", "fxLayoutGap", "10px", 3, "formGroup"], ["fxLayout", "row", "fxLayoutGap", "10px"], ["fxFlex", "80", 3, "appearance"], ["formControlName", "streetName", "matInput", "", "required", "", 3, "readonly"], ["fxFlex", "20", 3, "appearance"], ["formControlName", "streetNumber", "matInput", "", "required", "", 3, "readonly"], ["formControlName", "postalCode", "matInput", "", "required", "", 3, "readonly"], ["fxFlex", "auto", 3, "appearance", 4, "ngIf"], ["formGroupName", "locality", "fxFlex", "auto"], ["fxFlex", "auto", 3, "appearance"], ["formControlName", "long", "matInput", "", "required", "", 3, "readonly"], ["color", "primary", "matSuffix", ""], ["fxFlex", "100"], ["matGoogleMapsAutocomplete", "", "matInput", "", "required", "", 3, "country", "placeIdOnly", "strictBounds", "types", "type", "onAutocompleteSelected"], ["matInput", "", "formControlName", "vicinity", 3, "readonly"]], template: function MatSearchGoogleMapsAutocompleteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, MatSearchGoogleMapsAutocompleteComponent_div_1_Template, 7, 11, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "form", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelementStart(4, "mat-form-field", 4);
        ɵngcc0.ɵɵelementStart(5, "mat-label");
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(7, "input", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "mat-form-field", 6);
        ɵngcc0.ɵɵelementStart(9, "mat-label");
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(11, "input", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "div", 3);
        ɵngcc0.ɵɵelementStart(13, "mat-form-field", 6);
        ɵngcc0.ɵɵelementStart(14, "mat-label");
        ɵngcc0.ɵɵtext(15);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(16, "input", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(17, MatSearchGoogleMapsAutocompleteComponent_mat_form_field_17_Template, 4, 7, "mat-form-field", 9);
        ɵngcc0.ɵɵelementStart(18, "div", 10);
        ɵngcc0.ɵɵelementStart(19, "mat-form-field", 11);
        ɵngcc0.ɵɵelementStart(20, "mat-label");
        ɵngcc0.ɵɵtext(21);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(22, "input", 12);
        ɵngcc0.ɵɵelementStart(23, "mat-icon", 13);
        ɵngcc0.ɵɵtext(24, "add_location");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.disableSearch);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("formGroup", ctx.addressFormGroup);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("appearance", ctx.appearance)("@animate", ɵngcc0.ɵɵpureFunction1(20, _c2, ɵngcc0.ɵɵpureFunction0(19, _c1)));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.streetNameLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("readonly", ctx.readonly);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("appearance", ctx.appearance)("@animate", ɵngcc0.ɵɵpureFunction1(23, _c2, ɵngcc0.ɵɵpureFunction0(22, _c1)));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.streetNumberLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("readonly", ctx.readonly);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("appearance", ctx.appearance)("@animate", ɵngcc0.ɵɵpureFunction1(26, _c2, ɵngcc0.ɵɵpureFunction0(25, _c1)));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.postalCodeLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("readonly", ctx.readonly);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showVicinity);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("appearance", ctx.appearance)("@animate", ɵngcc0.ɵɵpureFunction1(29, _c2, ɵngcc0.ɵɵpureFunction0(28, _c1)));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.localityLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("readonly", ctx.readonly);
    } }, directives: function () { return [ɵngcc6.DefaultLayoutDirective, ɵngcc5.NgIf, ɵngcc4.ɵangular_packages_forms_forms_y, ɵngcc4.NgControlStatusGroup, ɵngcc6.DefaultFlexDirective, ɵngcc6.DefaultLayoutGapDirective, ɵngcc4.FormGroupDirective, ɵngcc2.MatFormField, ɵngcc2.MatLabel, ɵngcc4.DefaultValueAccessor, ɵngcc3.MatInput, ɵngcc4.NgControlStatus, ɵngcc4.FormControlName, ɵngcc4.RequiredValidator, ɵngcc4.FormGroupName, ɵngcc7.MatIcon, ɵngcc2.MatSuffix, MatGoogleMapsAutocompleteDirective]; }, styles: [""], data: { animation: InputAnimations } });
/** @nocollapse */
MatSearchGoogleMapsAutocompleteComponent.ctorParameters = () => [
    { type: FormBuilder }
];
MatSearchGoogleMapsAutocompleteComponent.propDecorators = {
    appearance: [{ type: Input }],
    searchAddressLabel: [{ type: Input }],
    streetNameLabel: [{ type: Input }],
    streetNumberLabel: [{ type: Input }],
    postalCodeLabel: [{ type: Input }],
    localityLabel: [{ type: Input }],
    vicinityLabel: [{ type: Input }],
    showVicinity: [{ type: Input }],
    country: [{ type: Input }],
    placeIdOnly: [{ type: Input }],
    strictBounds: [{ type: Input }],
    types: [{ type: Input }],
    type: [{ type: Input }],
    readonly: [{ type: Input }],
    disableSearch: [{ type: Input }],
    value: [{ type: Input }],
    onGermanAddressMapped: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatSearchGoogleMapsAutocompleteComponent, [{
        type: Component,
        args: [{
                selector: 'mat-search-google-maps-autocomplete',
                template: "<div fxLayout=\"column\">\n  <div *ngIf=\"!disableSearch\" fxFlex=\"100\">\n    <!--search address-->\n    <mat-form-field fxFlex=\"auto\" [appearance]=\"appearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n      <mat-label>{{searchAddressLabel}}</mat-label>\n      <input\n        (onAutocompleteSelected)=\"syncAutoComplete($event)\"\n        [country]=\"country\"\n        [placeIdOnly]=\"placeIdOnly\"\n        [strictBounds]=\"strictBounds\"\n        [types]=\"types\"\n        [type]=\"type\"\n        matGoogleMapsAutocomplete\n        matInput\n        required\n      />\n      <mat-icon color=\"primary\" matSuffix>search</mat-icon>\n      <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n    </mat-form-field>\n  </div>\n\n  <form [formGroup]=\"addressFormGroup\" fxFlex fxLayoutGap=\"10px\">\n    <div fxLayout=\"row\" fxLayoutGap=\"10px\">\n      <mat-form-field fxFlex=\"80\"\n                      [appearance]=\"appearance\"\n                      [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{streetNameLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          formControlName=\"streetName\"\n          matInput\n          required\n        />\n        <!--        <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>-->\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n      </mat-form-field>\n      <mat-form-field fxFlex=\"20\" [appearance]=\"appearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{streetNumberLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          formControlName=\"streetNumber\"\n          matInput\n          required\n        />\n        <!--        <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>-->\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n      </mat-form-field>\n    </div>\n    <div fxLayout=\"row\" fxLayoutGap=\"10px\">\n      <mat-form-field fxFlex=\"20\" [appearance]=\"appearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{postalCodeLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          formControlName=\"postalCode\"\n          matInput\n          required\n        />\n        <!--        <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>-->\n        <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n      </mat-form-field>\n      <mat-form-field *ngIf=\"showVicinity\" fxFlex=\"auto\"\n                      [appearance]=\"appearance\"\n                      [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n        <mat-label>{{vicinityLabel}}</mat-label>\n        <input\n          [readonly]=\"readonly\"\n          matInput\n          formControlName=\"vicinity\"\n        />\n      </mat-form-field>\n      <div formGroupName=\"locality\" fxFlex=\"auto\">\n        <mat-form-field fxFlex=\"auto\" [appearance]=\"appearance\" [@animate]=\"{ value: '*', params: { y: '100%' } }\">\n          <mat-label>{{localityLabel}}</mat-label>\n          <input\n            [readonly]=\"readonly\"\n            formControlName=\"long\"\n            matInput\n            required\n          />\n          <mat-icon color=\"primary\" matSuffix>add_location</mat-icon>\n          <!--    <mat-error>{{ 'msa.contactData.currentAddress.error' | translate }}</mat-error>-->\n        </mat-form-field>\n      </div>\n    </div>\n  </form>\n</div>\n",
                animations: InputAnimations,
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc4.FormBuilder }]; }, { appearance: [{
            type: Input
        }], searchAddressLabel: [{
            type: Input
        }], streetNameLabel: [{
            type: Input
        }], streetNumberLabel: [{
            type: Input
        }], postalCodeLabel: [{
            type: Input
        }], localityLabel: [{
            type: Input
        }], vicinityLabel: [{
            type: Input
        }], onGermanAddressMapped: [{
            type: Output
        }], showVicinity: [{
            type: Input
        }], country: [{
            type: Input
        }], placeIdOnly: [{
            type: Input
        }], strictBounds: [{
            type: Input
        }], types: [{
            type: Input
        }], type: [{
            type: Input
        }], readonly: [{
            type: Input
        }], disableSearch: [{
            type: Input
        }], value: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.appearance;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.searchAddressLabel;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.streetNameLabel;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.streetNumberLabel;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.postalCodeLabel;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.localityLabel;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.vicinityLabel;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.showVicinity;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.country;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.placeIdOnly;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.strictBounds;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.types;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.type;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.readonly;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.disableSearch;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.value;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.onGermanAddressMapped;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.germanAddress;
    /** @type {?} */
    MatSearchGoogleMapsAutocompleteComponent.prototype.addressFormGroup;
    /**
     * @type {?}
     * @private
     */
    MatSearchGoogleMapsAutocompleteComponent.prototype.formBuilder;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/component/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/mat-google-maps-autocomplete.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatGoogleMapsAutocompleteDirective {
    /**
     * @param {?} platformId
     * @param {?} elemRef
     * @param {?} mapsAPILoader
     * @param {?} ngZone
     */
    constructor(platformId, elemRef, mapsAPILoader, ngZone) {
        this.platformId = platformId;
        this.elemRef = elemRef;
        this.mapsAPILoader = mapsAPILoader;
        this.ngZone = ngZone;
        this.autoCompleteOptions = {};
        this.onChange = new EventEmitter();
        this.onAutocompleteSelected = new EventEmitter();
        this.onGermanAddressMapped = new EventEmitter();
        this.onLocationSelected = new EventEmitter();
        this.onNewPlaceResult = new EventEmitter();
        this.addressValidator = new MatValidateAddressDirective();
        this.addressSearchControl = new FormControl({ value: null }, Validators.compose([
            Validators.required,
            this.addressValidator.validate()
        ]));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (isPlatformBrowser(this.platformId)) {
            this.addressValidator.subscribe(this.onNewPlaceResult);
            /** @type {?} */
            const options = {
                // types: ['address'],
                // componentRestrictions: {country: this.country},
                placeIdOnly: this.placeIdOnly,
                strictBounds: this.strictBounds,
                // types: this.types,
                type: this.type
            };
            // tslint:disable-next-line:no-unused-expression
            this.country ? options.componentRestrictions = { country: this.country } : null;
            // tslint:disable-next-line:no-unused-expression
            this.country ? options.types = this.types : null;
            this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);
            this.initGoogleMapsAutocomplete();
        }
    }
    /**
     * @return {?}
     */
    initGoogleMapsAutocomplete() {
        this.mapsAPILoader
            .load()
            .then((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const autocomplete = new google.maps.places.Autocomplete(this.elemRef.nativeElement, this.autoCompleteOptions);
            autocomplete.addListener('place_changed', (/**
             * @return {?}
             */
            () => {
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => {
                    // get the place result
                    /** @type {?} */
                    const place = autocomplete.getPlace();
                    /** @type {?} */
                    const germanAddress = {
                        gmID: place.id,
                        icon: place.icon,
                        url: place.url,
                        placeID: place.place_id,
                        displayAddress: place.formatted_address,
                        name: place.name,
                        vicinity: place.vicinity,
                        locality: {},
                        state: {},
                        country: {},
                        geoLocation: { latitude: -1, longitude: -1 },
                    };
                    if (place.geometry && place.geometry.location) {
                        germanAddress.geoLocation.latitude = place.geometry.location.lat();
                        germanAddress.geoLocation.longitude = place.geometry.location.lng();
                    }
                    place.address_components.forEach((/**
                     * @param {?} value
                     * @return {?}
                     */
                    value => {
                        if (value.types.indexOf('street_number') > -1) {
                            germanAddress.streetNumber = value.short_name;
                        }
                        if (value.types.indexOf('route') > -1) {
                            germanAddress.streetName = value.long_name;
                        }
                        if (value.types.indexOf('postal_code') > -1) {
                            germanAddress.postalCode = Number(value.short_name);
                        }
                        if (value.types.indexOf('sublocality') > -1) {
                            germanAddress.sublocality = value.long_name;
                        }
                        if (value.types.indexOf('locality') > -1) {
                            germanAddress.locality.long = value.long_name;
                            germanAddress.locality.short = value.short_name;
                        }
                        if (value.types.indexOf('administrative_area_level_1') > -1) {
                            germanAddress.state.long = value.long_name;
                            germanAddress.state.short = value.short_name;
                        }
                        if (value.types.indexOf('country') > -1) {
                            germanAddress.country.long = value.long_name;
                            germanAddress.country.short = value.short_name;
                        }
                        if (value.types.indexOf('administrative_area_level_3') > -1) {
                            germanAddress.locality.short = value.short_name;
                        }
                    }));
                    this.onGermanAddressMapped.emit(germanAddress);
                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {
                        // place result is not valid
                        return;
                    }
                    else {
                        // show dialog to select a address from the input
                        // emit failed event
                    }
                    this.address = place.formatted_address;
                    this.onAutocompleteSelected.emit(place);
                    this.onLocationSelected.emit({
                        latitude: place.geometry.location.lat(),
                        longitude: place.geometry.location.lng()
                    });
                }));
            }));
        }))
            .catch((/**
         * @param {?} err
         * @return {?}
         */
        (err) => console.log(err)));
    }
}
MatGoogleMapsAutocompleteDirective.ɵfac = function MatGoogleMapsAutocompleteDirective_Factory(t) { return new (t || MatGoogleMapsAutocompleteDirective)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.MapsAPILoader), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
MatGoogleMapsAutocompleteDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatGoogleMapsAutocompleteDirective, selectors: [["", "matGoogleMapsAutocomplete", ""]], inputs: { autoCompleteOptions: "autoCompleteOptions", address: "address", country: "country", placeIdOnly: "placeIdOnly", strictBounds: "strictBounds", types: "types", type: "type" }, outputs: { onChange: "onChange", onAutocompleteSelected: "onAutocompleteSelected", onGermanAddressMapped: "onGermanAddressMapped", onLocationSelected: "onLocationSelected" }, exportAs: ["matGoogleMapsAutocomplete"] });
/** @nocollapse */
MatGoogleMapsAutocompleteDirective.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: ElementRef },
    { type: MapsAPILoader },
    { type: NgZone }
];
MatGoogleMapsAutocompleteDirective.propDecorators = {
    address: [{ type: Input }],
    country: [{ type: Input }],
    placeIdOnly: [{ type: Input }],
    strictBounds: [{ type: Input }],
    types: [{ type: Input }],
    type: [{ type: Input }],
    autoCompleteOptions: [{ type: Input }],
    onChange: [{ type: Output }],
    onAutocompleteSelected: [{ type: Output }],
    onGermanAddressMapped: [{ type: Output }],
    onLocationSelected: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatGoogleMapsAutocompleteDirective, [{
        type: Directive,
        args: [{
                selector: '[matGoogleMapsAutocomplete]',
                exportAs: 'matGoogleMapsAutocomplete'
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.MapsAPILoader }, { type: ɵngcc0.NgZone }]; }, { autoCompleteOptions: [{
            type: Input
        }], onChange: [{
            type: Output
        }], onAutocompleteSelected: [{
            type: Output
        }], onGermanAddressMapped: [{
            type: Output
        }], onLocationSelected: [{
            type: Output
        }], address: [{
            type: Input
        }], country: [{
            type: Input
        }], placeIdOnly: [{
            type: Input
        }], strictBounds: [{
            type: Input
        }], types: [{
            type: Input
        }], type: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.address;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.country;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.placeIdOnly;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.strictBounds;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.types;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.type;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.autoCompleteOptions;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.onChange;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.onAutocompleteSelected;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.onGermanAddressMapped;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.onLocationSelected;
    /**
     * @type {?}
     * @private
     */
    MatGoogleMapsAutocompleteDirective.prototype.onNewPlaceResult;
    /**
     * @type {?}
     * @private
     */
    MatGoogleMapsAutocompleteDirective.prototype.addressValidator;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.addressSearchControl;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.platformId;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.elemRef;
    /** @type {?} */
    MatGoogleMapsAutocompleteDirective.prototype.mapsAPILoader;
    /**
     * @type {?}
     * @private
     */
    MatGoogleMapsAutocompleteDirective.prototype.ngZone;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/mat-google-maps-autocomplete.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MatGoogleMapsAutocompleteModule {
}
MatGoogleMapsAutocompleteModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatGoogleMapsAutocompleteModule });
MatGoogleMapsAutocompleteModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MatGoogleMapsAutocompleteModule_Factory(t) { return new (t || MatGoogleMapsAutocompleteModule)(); }, imports: [[
            CommonModule,
            FormsModule,
            ReactiveFormsModule,
            FlexLayoutModule,
            MatInputModule,
            MatIconModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatGoogleMapsAutocompleteModule, { declarations: function () { return [MatGoogleMapsAutocompleteComponent,
        MatGoogleMapsAutocompleteDirective,
        MatValidateAddressDirective,
        MatSearchGoogleMapsAutocompleteComponent]; }, imports: function () { return [CommonModule,
        FormsModule,
        ReactiveFormsModule,
        FlexLayoutModule,
        MatInputModule,
        MatIconModule]; }, exports: function () { return [MatGoogleMapsAutocompleteComponent,
        MatGoogleMapsAutocompleteDirective,
        MatValidateAddressDirective,
        MatSearchGoogleMapsAutocompleteComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatGoogleMapsAutocompleteModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    FlexLayoutModule,
                    MatInputModule,
                    MatIconModule
                ],
                exports: [
                    MatGoogleMapsAutocompleteComponent,
                    MatGoogleMapsAutocompleteDirective,
                    MatValidateAddressDirective,
                    MatSearchGoogleMapsAutocompleteComponent
                ],
                declarations: [
                    MatGoogleMapsAutocompleteComponent,
                    MatGoogleMapsAutocompleteDirective,
                    MatValidateAddressDirective,
                    MatSearchGoogleMapsAutocompleteComponent
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: angular-material-extensions-google-maps-autocomplete.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { Appearance, MatGoogleMapsAutocompleteComponent, MatGoogleMapsAutocompleteDirective, MatGoogleMapsAutocompleteModule, MatSearchGoogleMapsAutocompleteComponent, MatValidateAddressDirective, MatGoogleMapsAutocompleteComponent as ɵa, MatSearchGoogleMapsAutocompleteComponent as ɵb, InputAnimations as ɵc };

//# sourceMappingURL=angular-material-extensions-google-maps-autocomplete.js.map